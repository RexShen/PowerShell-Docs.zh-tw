---
ms.date: 09/13/2016
ms.topic: reference
title: 強烈建議使用的開發指導方針
description: 強烈建議使用的開發指導方針
ms.openlocfilehash: e12fa0d1adc0d7a0dad938457bdcd289736df97c
ms.sourcegitcommit: ba7315a496986451cfc1296b659d73ea2373d3f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/10/2020
ms.locfileid: "93355233"
---
# <a name="strongly-encouraged-development-guidelines"></a><span data-ttu-id="106f1-103">強烈建議使用的開發指導方針</span><span class="sxs-lookup"><span data-stu-id="106f1-103">Strongly Encouraged Development Guidelines</span></span>

<span data-ttu-id="106f1-104">本節說明當您撰寫 Cmdlet 時應遵循的指導方針。</span><span class="sxs-lookup"><span data-stu-id="106f1-104">This section describes guidelines that you should follow when you write your cmdlets.</span></span> <span data-ttu-id="106f1-105">它們分成設計 Cmdlet 的指導方針和撰寫 Cmdlet 程式碼的指導方針。</span><span class="sxs-lookup"><span data-stu-id="106f1-105">They are separated into guidelines for designing cmdlets and guidelines for writing your cmdlet code.</span></span> <span data-ttu-id="106f1-106">您可能會發現這些指導方針並不適用于每個案例。</span><span class="sxs-lookup"><span data-stu-id="106f1-106">You might find that these guidelines are not applicable for every scenario.</span></span> <span data-ttu-id="106f1-107">但是，如果已套用這些原則，而您未遵循這些指導方針，則當使用者使用您的 Cmdlet 時，可能會有不佳的體驗。</span><span class="sxs-lookup"><span data-stu-id="106f1-107">However, if they do apply and you do not follow these guidelines, your users might have a poor experience when they use your cmdlets.</span></span>

## <a name="design-guidelines"></a><span data-ttu-id="106f1-108">設計方針</span><span class="sxs-lookup"><span data-stu-id="106f1-108">Design Guidelines</span></span>

<span data-ttu-id="106f1-109">設計 Cmdlet 時，應遵循下列指導方針，以確保使用您的 Cmdlet 與其他 Cmdlet 之間的使用者體驗一致。</span><span class="sxs-lookup"><span data-stu-id="106f1-109">The following guidelines should be followed when designing cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="106f1-110">當您找到適用于您情況的設計指導方針時，請務必查看類似指導方針的程式碼指導方針。</span><span class="sxs-lookup"><span data-stu-id="106f1-110">When you find a Design guideline that applies to your situation, be sure to look at the Code guidelines for similar guidelines.</span></span>

### <a name="use-a-specific-noun-for-a-cmdlet-name-sd01"></a><span data-ttu-id="106f1-111">使用特定名詞作為 Cmdlet 名稱 (SD01) </span><span class="sxs-lookup"><span data-stu-id="106f1-111">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>

<span data-ttu-id="106f1-112">Cmdlet 命名中使用的名詞需要非常明確，讓使用者能夠探索您的 Cmdlet。</span><span class="sxs-lookup"><span data-stu-id="106f1-112">Nouns used in cmdlet naming need to be very specific so that the user can discover your cmdlets.</span></span>
<span data-ttu-id="106f1-113">將一般名詞（例如 "server"）加上產品名稱的簡短版本。</span><span class="sxs-lookup"><span data-stu-id="106f1-113">Prefix generic nouns such as "server" with a shortened version of the product name.</span></span> <span data-ttu-id="106f1-114">例如，如果名詞參考的伺服器是執行 Microsoft SQL Server 的實例，請使用 "SQLServer" 這類名詞。</span><span class="sxs-lookup"><span data-stu-id="106f1-114">For example, if a noun refers to a server that is running an instance of Microsoft SQL Server, use a noun such as "SQLServer".</span></span> <span data-ttu-id="106f1-115">特定名詞的組合和核准動詞命令的簡短清單，可讓使用者快速探索和預期功能，同時避免在 Cmdlet 名稱之間重複。</span><span class="sxs-lookup"><span data-stu-id="106f1-115">The combination of specific nouns and the short list of approved verbs enable the user to quickly discover and anticipate functionality while avoiding duplication among cmdlet names.</span></span>

<span data-ttu-id="106f1-116">為了增強使用者體驗，您為 Cmdlet 名稱選擇的名詞應該是單數的。</span><span class="sxs-lookup"><span data-stu-id="106f1-116">To enhance the user experience, the noun that you choose for a cmdlet name should be singular.</span></span> <span data-ttu-id="106f1-117">例如，請使用名稱， `Get-Process` 而不要使用 **Get 進程**。</span><span class="sxs-lookup"><span data-stu-id="106f1-117">For example, use the name `Get-Process` instead of **Get-Processes**.</span></span> <span data-ttu-id="106f1-118">針對所有 Cmdlet 名稱，最好遵循此規則，即使 Cmdlet 可能會在多個專案上採取動作也是一樣。</span><span class="sxs-lookup"><span data-stu-id="106f1-118">It is best to follow this rule for all cmdlet names, even when a cmdlet is likely to act upon more than one item.</span></span>

### <a name="use-pascal-case-for-cmdlet-names-sd02"></a><span data-ttu-id="106f1-119">針對 Cmdlet 名稱使用 Pascal 案例 (SD02) </span><span class="sxs-lookup"><span data-stu-id="106f1-119">Use Pascal Case for Cmdlet Names (SD02)</span></span>

<span data-ttu-id="106f1-120">使用 Pascal 的參數名稱大寫。</span><span class="sxs-lookup"><span data-stu-id="106f1-120">Use Pascal case for parameter names.</span></span> <span data-ttu-id="106f1-121">換句話說，請將動詞的第一個字母和名詞中使用的所有詞彙做為大寫。</span><span class="sxs-lookup"><span data-stu-id="106f1-121">In other words, capitalize the first letter of verb and all terms used in the noun.</span></span> <span data-ttu-id="106f1-122">例如，"`Clear-ItemProperty`"。</span><span class="sxs-lookup"><span data-stu-id="106f1-122">For example, "`Clear-ItemProperty`".</span></span>

### <a name="parameter-design-guidelines-sd03"></a><span data-ttu-id="106f1-123">參數設計指導方針 (SD03) </span><span class="sxs-lookup"><span data-stu-id="106f1-123">Parameter Design Guidelines (SD03)</span></span>

<span data-ttu-id="106f1-124">Cmdlet 需要可接收其必須操作之資料的參數，以及表示用來判斷作業特性之資訊的參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-124">A cmdlet needs parameters that receive the data on which it must operate, and parameters that indicate information that is used to determine the characteristics of the operation.</span></span> <span data-ttu-id="106f1-125">例如，Cmdlet 可能會有一個 `Name` 從管線接收資料的參數，而此 Cmdlet 可能會有一個 `Force` 參數，表示可以強制執行 Cmdlet 來執行其作業。</span><span class="sxs-lookup"><span data-stu-id="106f1-125">For example, a cmdlet might have a `Name` parameter that receives data from the pipeline, and the cmdlet might have a `Force` parameter to indicate that the cmdlet can be forced to perform its operation.</span></span> <span data-ttu-id="106f1-126">Cmdlet 可以定義的參數數目沒有任何限制。</span><span class="sxs-lookup"><span data-stu-id="106f1-126">There is no limit to the number of parameters that a cmdlet can define.</span></span>

#### <a name="use-standard-parameter-names"></a><span data-ttu-id="106f1-127">使用標準參數名稱</span><span class="sxs-lookup"><span data-stu-id="106f1-127">Use Standard Parameter Names</span></span>

<span data-ttu-id="106f1-128">您的 Cmdlet 應使用標準參數名稱，讓使用者可以快速判斷特定參數的意義。</span><span class="sxs-lookup"><span data-stu-id="106f1-128">Your cmdlet should use standard parameter names so that the user can quickly determine what a particular parameter means.</span></span> <span data-ttu-id="106f1-129">如果需要更明確的名稱，請使用標準參數名稱，然後指定更明確的名稱做為別名。</span><span class="sxs-lookup"><span data-stu-id="106f1-129">If a more specific name is required, use a standard parameter name, and then specify a more specific name as an alias.</span></span> <span data-ttu-id="106f1-130">例如， `Get-Service` Cmdlet 有一個參數，該參數具有泛型名稱 (`Name`) ，而 () 更明確的別名 `ServiceName` 。</span><span class="sxs-lookup"><span data-stu-id="106f1-130">For example, the `Get-Service` cmdlet has a parameter that has a generic name (`Name`) and a more specific alias (`ServiceName`).</span></span> <span data-ttu-id="106f1-131">這兩個詞彙都可以用來指定參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-131">Both terms can be used to specify the parameter.</span></span>

<span data-ttu-id="106f1-132">如需參數名稱和其資料類型的詳細資訊，請參閱 [Cmdlet 參數名稱和功能指導方針](./standard-cmdlet-parameter-names-and-types.md)。</span><span class="sxs-lookup"><span data-stu-id="106f1-132">For more information about parameter names and their data types, see [Cmdlet Parameter Name and Functionality Guidelines](./standard-cmdlet-parameter-names-and-types.md).</span></span>

#### <a name="use-singular-parameter-names"></a><span data-ttu-id="106f1-133">使用單數參數名稱</span><span class="sxs-lookup"><span data-stu-id="106f1-133">Use Singular Parameter Names</span></span>

<span data-ttu-id="106f1-134">請避免針對其值為單一專案的參數使用複數名稱。</span><span class="sxs-lookup"><span data-stu-id="106f1-134">Avoid using plural names for parameters whose value is a single element.</span></span> <span data-ttu-id="106f1-135">這包括採用陣列或清單的參數，因為使用者可能會提供只有一個元素的陣列或清單。</span><span class="sxs-lookup"><span data-stu-id="106f1-135">This includes parameters that take arrays or lists because the user might supply an array or list with only one element.</span></span>

<span data-ttu-id="106f1-136">只有在參數的值一律為多元素值的情況下，才應該使用複數參數名稱。</span><span class="sxs-lookup"><span data-stu-id="106f1-136">Plural parameter names should be used only in those cases where the value of the parameter is always a multiple-element value.</span></span> <span data-ttu-id="106f1-137">在這些情況下，Cmdlet 應確認是否提供多個元素，如果未提供多個元素，則 Cmdlet 應該向使用者顯示警告。</span><span class="sxs-lookup"><span data-stu-id="106f1-137">In these cases, the cmdlet should verify that multiple elements are supplied, and the cmdlet should display a warning to the user if multiple elements are not supplied.</span></span>

#### <a name="use-pascal-case-for-parameter-names"></a><span data-ttu-id="106f1-138">使用 Pascal 的參數名稱案例</span><span class="sxs-lookup"><span data-stu-id="106f1-138">Use Pascal Case for Parameter Names</span></span>

<span data-ttu-id="106f1-139">使用 Pascal 的參數名稱大寫。</span><span class="sxs-lookup"><span data-stu-id="106f1-139">Use Pascal case for parameter names.</span></span> <span data-ttu-id="106f1-140">換句話說，在參數名稱中，每個單字的第一個字母都是大寫，包括名稱的第一個字母。</span><span class="sxs-lookup"><span data-stu-id="106f1-140">In other words, capitalize the first letter of each word in the parameter name, including the first letter of the name.</span></span> <span data-ttu-id="106f1-141">例如，參數名稱會 `ErrorAction` 使用正確的大小寫。</span><span class="sxs-lookup"><span data-stu-id="106f1-141">For example, the parameter name `ErrorAction` uses the correct capitalization.</span></span> <span data-ttu-id="106f1-142">下列參數名稱使用不正確的大小寫：</span><span class="sxs-lookup"><span data-stu-id="106f1-142">The following parameter names use incorrect capitalization:</span></span>

- `errorAction`
- `erroraction`

#### <a name="parameters-that-take-a-list-of-options"></a><span data-ttu-id="106f1-143">採用選項清單的參數</span><span class="sxs-lookup"><span data-stu-id="106f1-143">Parameters That Take a List of Options</span></span>

<span data-ttu-id="106f1-144">有兩種方式可以建立參數，其值可從一組選項中選取。</span><span class="sxs-lookup"><span data-stu-id="106f1-144">There are two ways to create a parameter whose value can be selected from a set of options.</span></span>

- <span data-ttu-id="106f1-145"> (定義列舉型別，或使用現有的列舉型別) 指定有效的值。</span><span class="sxs-lookup"><span data-stu-id="106f1-145">Define an enumeration type (or use an existing enumeration type) that specifies the valid values.</span></span>
  <span data-ttu-id="106f1-146">然後，使用列舉型別來建立該型別的參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-146">Then, use the enumeration type to create a parameter of that type.</span></span>

- <span data-ttu-id="106f1-147">將 **ValidateSet** 屬性加入至參數宣告。</span><span class="sxs-lookup"><span data-stu-id="106f1-147">Add the **ValidateSet** attribute to the parameter declaration.</span></span> <span data-ttu-id="106f1-148">如需此屬性的詳細資訊，請參閱 [ValidateSet 屬性聲明](./validateset-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="106f1-148">For more information about this attribute, see [ValidateSet Attribute Declaration](./validateset-attribute-declaration.md).</span></span>

#### <a name="use-standard-types-for-parameters"></a><span data-ttu-id="106f1-149">使用標準類型的參數</span><span class="sxs-lookup"><span data-stu-id="106f1-149">Use Standard Types for Parameters</span></span>

<span data-ttu-id="106f1-150">為了確保與其他指令程式一致，請在可能的情況下使用標準類型的參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-150">To ensure consistency with other cmdlets, use standard types for parameters where ever possible.</span></span> <span data-ttu-id="106f1-151">如需有關應用於不同參數之類型的詳細資訊，請參閱 [標準 Cmdlet 參數名稱和類型](./standard-cmdlet-parameter-names-and-types.md)。</span><span class="sxs-lookup"><span data-stu-id="106f1-151">For more information about the types that should be used for different parameter, see [Standard Cmdlet Parameter Names and Types](./standard-cmdlet-parameter-names-and-types.md).</span></span> <span data-ttu-id="106f1-152">本主題提供數個主題的連結，這些主題描述標準參數群組的名稱和 .NET Framework 類型，例如「活動參數」。</span><span class="sxs-lookup"><span data-stu-id="106f1-152">This topic provides links to several topics that describe the names and .NET Framework types for groups of standard parameters, such as the "activity parameters".</span></span>

#### <a name="use-strongly-typed-net-framework-types"></a><span data-ttu-id="106f1-153">使用 Strongly-Typed .NET Framework 類型</span><span class="sxs-lookup"><span data-stu-id="106f1-153">Use Strongly-Typed .NET Framework Types</span></span>

<span data-ttu-id="106f1-154">參數應定義為 .NET Framework 類型，以提供更好的參數驗證。</span><span class="sxs-lookup"><span data-stu-id="106f1-154">Parameters should be defined as .NET Framework types to provide better parameter validation.</span></span> <span data-ttu-id="106f1-155">例如，限制為一組值之一值的參數應定義為列舉型別。</span><span class="sxs-lookup"><span data-stu-id="106f1-155">For example, parameters that are restricted to one value from a set of values should be defined as an enumeration type.</span></span> <span data-ttu-id="106f1-156">若要支援統一資源識別項 (URI) 值，請將參數定義為[system.string 類型。](/dotnet/api/System.Uri)</span><span class="sxs-lookup"><span data-stu-id="106f1-156">To support a Uniform Resource Identifier (URI) value, define the parameter as a [System.Uri](/dotnet/api/System.Uri) type.</span></span> <span data-ttu-id="106f1-157">針對所有但自由格式的文字屬性，請避免基本的字串參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-157">Avoid basic string parameters for all but free-form text properties.</span></span>

#### <a name="use-consistent-parameter-types"></a><span data-ttu-id="106f1-158">使用一致的參數類型</span><span class="sxs-lookup"><span data-stu-id="106f1-158">Use Consistent Parameter Types</span></span>

<span data-ttu-id="106f1-159">當多個 Cmdlet 使用同一個參數時，請一律使用相同的參數類型。</span><span class="sxs-lookup"><span data-stu-id="106f1-159">When the same parameter is used by multiple cmdlets, always use the same parameter type.</span></span> <span data-ttu-id="106f1-160">例如，如果 `Process` 參數是一個 Cmdlet 的 [system.string](/dotnet/api/System.Int16) 類型，請勿讓 `Process` 另一個 Cmdlet 的參數 [成為 system.string](/dotnet/api/System.UInt16) 類型。</span><span class="sxs-lookup"><span data-stu-id="106f1-160">For example, if the `Process` parameter is an [System.Int16](/dotnet/api/System.Int16) type for one cmdlet, do not make the `Process` parameter for another cmdlet a [System.Uint16](/dotnet/api/System.UInt16) type.</span></span>

#### <a name="parameters-that-take-true-and-false"></a><span data-ttu-id="106f1-161">採用 True 和 False 的參數</span><span class="sxs-lookup"><span data-stu-id="106f1-161">Parameters That Take True and False</span></span>

<span data-ttu-id="106f1-162">如果您的參數只接受 `true` 和 `false` ，請將參數定義為 [SwitchParameter](/dotnet/api/System.Management.Automation.SwitchParameter)類型。</span><span class="sxs-lookup"><span data-stu-id="106f1-162">If your parameter takes only `true` and `false`, define the parameter as type [System.Management.Automation.SwitchParameter](/dotnet/api/System.Management.Automation.SwitchParameter).</span></span>
<span data-ttu-id="106f1-163">切換參數會被視為 `true` 命令中指定的參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-163">A switch parameter is treated as `true` when it is specified in a command.</span></span> <span data-ttu-id="106f1-164">如果命令中未包含參數，Windows PowerShell 會將參數的值視為 `false` 。</span><span class="sxs-lookup"><span data-stu-id="106f1-164">If the parameter is not included in a command, Windows PowerShell considers the value of the parameter to be `false`.</span></span> <span data-ttu-id="106f1-165">請勿定義布林值參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-165">Do not define Boolean parameters.</span></span>

<span data-ttu-id="106f1-166">如果您的參數需要區分3個值： $true、$false 和「未指定」，請將類型的參數定義為可為 Null \<bool> 。</span><span class="sxs-lookup"><span data-stu-id="106f1-166">If your parameter needs to differentiate between 3 values: $true, $false and "unspecified", then define a parameter of type Nullable\<bool>.</span></span> <span data-ttu-id="106f1-167">當 Cmdlet 可以修改物件的布林值屬性時，通常會發生第三個「未指定」值的需求。</span><span class="sxs-lookup"><span data-stu-id="106f1-167">The need for a 3rd, "unspecified" value typically occurs when the cmdlet can modify a Boolean property of an object.</span></span> <span data-ttu-id="106f1-168">在此情況下，「未指定」表示不變更屬性的目前值。</span><span class="sxs-lookup"><span data-stu-id="106f1-168">In this case "unspecified" means to not change the current value of the property.</span></span>

#### <a name="support-arrays-for-parameters"></a><span data-ttu-id="106f1-169">支援參數的陣列</span><span class="sxs-lookup"><span data-stu-id="106f1-169">Support Arrays for Parameters</span></span>

<span data-ttu-id="106f1-170">使用者通常必須對多個引數執行相同的作業。</span><span class="sxs-lookup"><span data-stu-id="106f1-170">Frequently, users must perform the same operation against multiple arguments.</span></span> <span data-ttu-id="106f1-171">針對這些使用者，Cmdlet 應接受陣列作為參數輸入，讓使用者可以將引數以 Windows PowerShell 變數的形式傳遞至參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-171">For these users, a cmdlet should accept an array as parameter input so that a user can pass the arguments into the parameter as a Windows PowerShell variable.</span></span> <span data-ttu-id="106f1-172">例如， [取得程式](/powershell/module/Microsoft.PowerShell.Management/Get-Process) Cmdlet 會使用字串陣列來識別要抓取之進程的名稱。</span><span class="sxs-lookup"><span data-stu-id="106f1-172">For example, the [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet uses an array for the strings that identify the names of the processes to retrieve.</span></span>

#### <a name="support-the-passthru-parameter"></a><span data-ttu-id="106f1-173">支援 PassThru 參數</span><span class="sxs-lookup"><span data-stu-id="106f1-173">Support the PassThru Parameter</span></span>

<span data-ttu-id="106f1-174">根據預設，許多修改系統的 Cmdlet （例如， [停止進程](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) Cmdlet）都會作為物件的「接收器」，而不會傳回結果。</span><span class="sxs-lookup"><span data-stu-id="106f1-174">By default, many cmdlets that modify the system, such as the [Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet, act as "sinks" for objects and do not return a result.</span></span> <span data-ttu-id="106f1-175">這些 Cmdlet 應執行 `PassThru` 參數，以強制 Cmdlet 傳回物件。</span><span class="sxs-lookup"><span data-stu-id="106f1-175">These cmdlet should implement the `PassThru` parameter to force the cmdlet to return an object.</span></span> <span data-ttu-id="106f1-176">當 `PassThru` 指定參數時，此 Cmdlet 會使用 [WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) 方法的呼叫傳回物件（）。</span><span class="sxs-lookup"><span data-stu-id="106f1-176">When the `PassThru` parameter is specified, the cmdlet returns an object by using a call to the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="106f1-177">例如，下列命令會停止 Calc 處理常式，並將結果進程傳遞至管線。</span><span class="sxs-lookup"><span data-stu-id="106f1-177">For example, the following command stops the Calc process and passes the resultant process to the pipeline.</span></span>

```powershell
Stop-Process calc -passthru
```

<span data-ttu-id="106f1-178">在大多數情況下，新增、設定和新的 Cmdlet 都應該支援 `PassThru` 參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-178">In most cases, Add, Set, and New cmdlets should support a `PassThru` parameter.</span></span>

#### <a name="support-parameter-sets"></a><span data-ttu-id="106f1-179">支援參數集</span><span class="sxs-lookup"><span data-stu-id="106f1-179">Support Parameter Sets</span></span>

<span data-ttu-id="106f1-180">Cmdlet 旨在完成單一用途。</span><span class="sxs-lookup"><span data-stu-id="106f1-180">A cmdlet is intended to accomplish a single purpose.</span></span> <span data-ttu-id="106f1-181">不過，通常會有一種以上的方法來描述作業或操作目標。</span><span class="sxs-lookup"><span data-stu-id="106f1-181">However, there is frequently more than one way to describe the operation or the operation target.</span></span> <span data-ttu-id="106f1-182">例如，進程可能會以其名稱、識別碼或處理常式物件來識別。</span><span class="sxs-lookup"><span data-stu-id="106f1-182">For example, a process might be identified by its name, by its identifier, or by a process object.</span></span> <span data-ttu-id="106f1-183">此 Cmdlet 應支援其目標的所有合理表示。</span><span class="sxs-lookup"><span data-stu-id="106f1-183">The cmdlet should support all the reasonable representations of its targets.</span></span> <span data-ttu-id="106f1-184">一般來說，此 Cmdlet 會藉由指定參數集 (稱為參數集來滿足這項需求，) 會一起運作。</span><span class="sxs-lookup"><span data-stu-id="106f1-184">Normally, the cmdlet satisfies this requirement by specifying sets of parameters (referred to as parameter sets) that operate together.</span></span> <span data-ttu-id="106f1-185">單一參數可以屬於任意數目的參數集合。</span><span class="sxs-lookup"><span data-stu-id="106f1-185">A single parameter can belong to any number of parameter sets.</span></span> <span data-ttu-id="106f1-186">如需參數集的詳細資訊，請參閱 [Cmdlet 參數集](./cmdlet-parameter-sets.md)。</span><span class="sxs-lookup"><span data-stu-id="106f1-186">For more information about parameter sets, see [Cmdlet Parameter Sets](./cmdlet-parameter-sets.md).</span></span>

<span data-ttu-id="106f1-187">當您指定參數集時，請將集合中的一個參數設定為 ValueFromPipeline。</span><span class="sxs-lookup"><span data-stu-id="106f1-187">When you specify parameter sets, set only one parameter in the set to ValueFromPipeline.</span></span> <span data-ttu-id="106f1-188">如需如何宣告 **參數** 屬性的詳細資訊，請參閱 [ParameterAttribute](./parameter-attribute-declaration.md)宣告。</span><span class="sxs-lookup"><span data-stu-id="106f1-188">For more information about how to declare the **Parameter** attribute, see [ParameterAttribute Declaration](./parameter-attribute-declaration.md).</span></span>

<span data-ttu-id="106f1-189">使用參數集時，會由 **Cmdlet** 屬性定義預設參數集。</span><span class="sxs-lookup"><span data-stu-id="106f1-189">When parameter sets are used, the default parameter set is defined by the **Cmdlet** attribute.</span></span> <span data-ttu-id="106f1-190">預設參數集應該包含互動式 Windows PowerShell 會話中最有可能使用的參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-190">The default parameter set should include the parameters most likely to be used in an interactive Windows PowerShell session.</span></span> <span data-ttu-id="106f1-191">如需如何宣告 **Cmdlet** 屬性的詳細資訊，請參閱 [CmdletAttribute](./cmdlet-attribute-declaration.md)宣告。</span><span class="sxs-lookup"><span data-stu-id="106f1-191">For more information about how to declare the **Cmdlet** attribute, see [CmdletAttribute Declaration](./cmdlet-attribute-declaration.md).</span></span>

### <a name="provide-feedback-to-the-user-sd04"></a><span data-ttu-id="106f1-192">將意見反應提供給使用者 (SD04) </span><span class="sxs-lookup"><span data-stu-id="106f1-192">Provide Feedback to the User (SD04)</span></span>

<span data-ttu-id="106f1-193">使用本節中的指導方針，將意見反應提供給使用者。</span><span class="sxs-lookup"><span data-stu-id="106f1-193">Use the guidelines in this section to provide feedback to the user.</span></span> <span data-ttu-id="106f1-194">這項意見反應可讓使用者瞭解系統中發生的狀況，並做出更佳的系統管理決策。</span><span class="sxs-lookup"><span data-stu-id="106f1-194">This feedback allows the user to be aware of what is occurring in the system and to make better administrative decisions.</span></span>

<span data-ttu-id="106f1-195">Windows PowerShell 執行時間可讓使用者藉 `Write` 由設定喜好設定變數，指定如何處理每個方法呼叫的輸出。</span><span class="sxs-lookup"><span data-stu-id="106f1-195">The Windows PowerShell runtime allows a user to specify how to handle output from each call to the `Write` method by setting a preference variable.</span></span> <span data-ttu-id="106f1-196">使用者可以設定數個喜好設定變數，包括決定系統是否應該顯示資訊的變數，以及決定系統是否應該在採取進一步動作之前查詢使用者的變數。</span><span class="sxs-lookup"><span data-stu-id="106f1-196">The user can set several preference variables, including a variable that determines whether the system should display information and a variable that determines whether the system should query the user before taking further action.</span></span>

#### <a name="support-the-writewarning-writeverbose-and-writedebug-methods"></a><span data-ttu-id="106f1-197">支援 WriteWarning、WriteVerbose 和 WriteDebug 方法</span><span class="sxs-lookup"><span data-stu-id="106f1-197">Support the WriteWarning, WriteVerbose, and WriteDebug Methods</span></span>

<span data-ttu-id="106f1-198">當 Cmdlet 即將執行可能會產生非預期結果的作業時，指令程式應呼叫 [WriteWarning](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) 方法。</span><span class="sxs-lookup"><span data-stu-id="106f1-198">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteWarning](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) method when the cmdlet is about to perform an operation that might have an unintended result.</span></span> <span data-ttu-id="106f1-199">例如，如果 Cmdlet 即將覆寫唯讀檔案，則 Cmdlet 應該呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="106f1-199">For example, a cmdlet should call this method if the cmdlet is about to overwrite a read-only file.</span></span>

<span data-ttu-id="106f1-200">當使用者需要有關 Cmdlet 所執行之工作的詳細資訊時，Cmdlet 應呼叫 [WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) 方法。</span><span class="sxs-lookup"><span data-stu-id="106f1-200">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method when the user requires some detail about what the cmdlet is doing.</span></span> <span data-ttu-id="106f1-201">例如，如果 Cmdlet 作者覺得有一些案例可能需要更多有關 Cmdlet 所做的資訊，則 Cmdlet 應呼叫此資訊。</span><span class="sxs-lookup"><span data-stu-id="106f1-201">For example, a cmdlet should call this information if the cmdlet author feels that there are scenarios that might require more information about what the cmdlet is doing.</span></span>

<span data-ttu-id="106f1-202">當開發人員或產品支援工程師必須瞭解 Cmdlet 作業損毀時，此 Cmdlet 應該呼叫 [WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) 方法。</span><span class="sxs-lookup"><span data-stu-id="106f1-202">The cmdlet should call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method when a developer or product support engineer must understand what has corrupted the cmdlet operation.</span></span> <span data-ttu-id="106f1-203">Cmdlet 不需要在呼叫[WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose)方法的相同程式碼中呼叫[WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug)方法，因為此 `Debug` 參數會顯示這兩組資訊。（此參數）會顯示這兩組資訊。</span><span class="sxs-lookup"><span data-stu-id="106f1-203">It is not necessary for the cmdlet to call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method in the same code that calls the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method because the `Debug` parameter presents both sets of information.</span></span>

#### <a name="support-writeprogress-for-operations-that-take-a-long-time"></a><span data-ttu-id="106f1-204">針對花費很長時間的作業支援 WriteProgress</span><span class="sxs-lookup"><span data-stu-id="106f1-204">Support WriteProgress for Operations that take a Long Time</span></span>

<span data-ttu-id="106f1-205">需要很長時間才能完成，而且無法在背景中執行的 Cmdlet 作業，應該透過 [WriteProgress](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) 方法的定期呼叫來支援進度報告。</span><span class="sxs-lookup"><span data-stu-id="106f1-205">Cmdlet operations that take a long time to complete and that cannot run in the background should support progress reporting through periodic calls to the [System.Management.Automation.Cmdlet.WriteProgress](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) method.</span></span>

#### <a name="use-the-host-interfaces"></a><span data-ttu-id="106f1-206">使用主機介面</span><span class="sxs-lookup"><span data-stu-id="106f1-206">Use the Host Interfaces</span></span>

<span data-ttu-id="106f1-207">在此情況下，Cmdlet 必須直接與使用者進行通訊，而不是使用不同的寫入，或應該是由 [system.object](/dotnet/api/System.Management.Automation.Cmdlet) 類別支援的方法。</span><span class="sxs-lookup"><span data-stu-id="106f1-207">Occasionally, a cmdlet must communicate directly with the user instead of by using the various Write or Should methods supported by the [System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet) class.</span></span> <span data-ttu-id="106f1-208">在此情況下，此 Cmdlet 應該衍生自 [PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) 類別，並使用 [PSCmdlet. Host \*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) 屬性（property）。</span><span class="sxs-lookup"><span data-stu-id="106f1-208">In this case, the cmdlet should derive from the [System.Management.Automation.PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) class and use the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="106f1-209">這個屬性支援不同層級的通訊類型，包括 PromptForChoice、Prompt 和 WriteLine/ReadLine 類型。</span><span class="sxs-lookup"><span data-stu-id="106f1-209">This property supports different levels of communication type, including the PromptForChoice, Prompt, and WriteLine/ReadLine types.</span></span> <span data-ttu-id="106f1-210">在最特定的層級中，它也提供讀取和寫入個別金鑰以及處理緩衝區的方式。</span><span class="sxs-lookup"><span data-stu-id="106f1-210">At the most specific level, it also provides ways to read and write individual keys and to deal with buffers.</span></span>

<span data-ttu-id="106f1-211">除非 Cmdlet 專門設計為產生圖形化使用者介面， (GUI) ，否則不應該使用 [PSCmdlet \*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) 屬性來略過主機。</span><span class="sxs-lookup"><span data-stu-id="106f1-211">Unless a cmdlet is specifically designed to generate a graphical user interface (GUI), it should not bypass the host by using the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="106f1-212">設計用來產生 GUI 的 Cmdlet 範例是 [Out GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) Cmdlet。</span><span class="sxs-lookup"><span data-stu-id="106f1-212">An example of a cmdlet that is designed to generate a GUI is the [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet.</span></span>

> [!NOTE]
> <span data-ttu-id="106f1-213">Cmdlet 不應使用 [System. Console](/dotnet/api/System.Console) API。</span><span class="sxs-lookup"><span data-stu-id="106f1-213">Cmdlets should not use the [System.Console](/dotnet/api/System.Console) API.</span></span>

### <a name="create-a-cmdlet-help-file-sd05"></a><span data-ttu-id="106f1-214">建立 Cmdlet 說明檔 (SD05) </span><span class="sxs-lookup"><span data-stu-id="106f1-214">Create a Cmdlet Help File (SD05)</span></span>

<span data-ttu-id="106f1-215">針對每個 Cmdlet 元件建立 Help.xml 檔案，其中包含 Cmdlet 的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="106f1-215">For each cmdlet assembly, create a Help.xml file that contains information about the cmdlet.</span></span> <span data-ttu-id="106f1-216">這項資訊包含 Cmdlet 的描述、Cmdlet 參數的描述、Cmdlet 用法的範例等等。</span><span class="sxs-lookup"><span data-stu-id="106f1-216">This information includes a description of the cmdlet, descriptions of the cmdlet's parameters, examples of the cmdlet's use, and more.</span></span>

## <a name="code-guidelines"></a><span data-ttu-id="106f1-217">程式碼指導方針</span><span class="sxs-lookup"><span data-stu-id="106f1-217">Code Guidelines</span></span>

<span data-ttu-id="106f1-218">在撰寫 Cmdlet 的程式碼時，應遵循下列指導方針，以確保使用您的 Cmdlet 與其他 Cmdlet 之間的使用者體驗一致。</span><span class="sxs-lookup"><span data-stu-id="106f1-218">The following guidelines should be followed when coding cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="106f1-219">當您找到適用于您的情況的程式碼指導方針時，請務必查看類似指導方針的設計指導方針。</span><span class="sxs-lookup"><span data-stu-id="106f1-219">When you find a Code guideline that applies to your situation, be sure to look at the Design guidelines for similar guidelines.</span></span>

### <a name="coding-parameters-sc01"></a><span data-ttu-id="106f1-220">編碼參數 (SC01) </span><span class="sxs-lookup"><span data-stu-id="106f1-220">Coding Parameters (SC01)</span></span>

<span data-ttu-id="106f1-221">宣告以 **參數** 屬性裝飾之 Cmdlet 類別的公用屬性，以定義參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-221">Define a parameter by declaring a public property of the cmdlet class that is decorated with the **Parameter** attribute.</span></span> <span data-ttu-id="106f1-222">參數不一定要是 Cmdlet 的衍生 .NET Framework 類別的靜態成員。</span><span class="sxs-lookup"><span data-stu-id="106f1-222">Parameters do not have to be static members of the derived .NET Framework class for the cmdlet.</span></span> <span data-ttu-id="106f1-223">如需如何宣告 **參數** 屬性的詳細資訊，請參閱 [參數屬性聲明](./parameter-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="106f1-223">For more information about how to declare the **Parameter** attribute, see [Parameter Attribute Declaration](./parameter-attribute-declaration.md).</span></span>

#### <a name="support-windows-powershell-paths"></a><span data-ttu-id="106f1-224">支援 Windows PowerShell 路徑</span><span class="sxs-lookup"><span data-stu-id="106f1-224">Support Windows PowerShell Paths</span></span>

<span data-ttu-id="106f1-225">Windows PowerShell 路徑是標準化命名空間存取的機制。</span><span class="sxs-lookup"><span data-stu-id="106f1-225">The Windows PowerShell path is the mechanism for normalizing access to namespaces.</span></span> <span data-ttu-id="106f1-226">當您將 Windows PowerShell 路徑指派給 Cmdlet 中的參數時，使用者可以定義自訂的 "drive" 作為特定路徑的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="106f1-226">When you assign a Windows PowerShell path to a parameter in the cmdlet, the user can define a custom "drive" that acts as a shortcut to a specific path.</span></span> <span data-ttu-id="106f1-227">當使用者指定這類磁片磁碟機時，儲存的資料（例如登錄中的資料）可以一致的方式使用。</span><span class="sxs-lookup"><span data-stu-id="106f1-227">When a user designates such a drive, stored data, such as data in the Registry, can be used in a consistent way.</span></span>

<span data-ttu-id="106f1-228">如果您的 Cmdlet 允許使用者指定檔案或資料來源，則應該定義 [system.string](/dotnet/api/System.String)類型的參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-228">If your cmdlet allows the user to specify a file or a data source, it should define a parameter of type [System.String](/dotnet/api/System.String).</span></span> <span data-ttu-id="106f1-229">如果支援多個磁片磁碟機，則類型應為數組。</span><span class="sxs-lookup"><span data-stu-id="106f1-229">If more than one drive is supported, the type should be an array.</span></span> <span data-ttu-id="106f1-230">參數的名稱應該是 `Path` ，別名為 `PSPath` 。</span><span class="sxs-lookup"><span data-stu-id="106f1-230">The name of the parameter should be `Path`, with an alias of `PSPath`.</span></span>
<span data-ttu-id="106f1-231">此外， `Path` 參數應該支援萬用字元。</span><span class="sxs-lookup"><span data-stu-id="106f1-231">Additionally, the `Path` parameter should support wildcard characters.</span></span> <span data-ttu-id="106f1-232">如果不需要支援萬用字元，請定義 `LiteralPath` 參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-232">If support for wildcard characters is not required, define a `LiteralPath` parameter.</span></span>

<span data-ttu-id="106f1-233">如果 Cmdlet 讀取或寫入的資料必須是檔案，則 Cmdlet 應接受 Windows PowerShell 的路徑輸入，而且 Cmdlet 應使用 [Sessionstate](/dotnet/api/System.Management.Automation.SessionState.Path) 屬性將 Windows PowerShell 路徑轉譯為檔案系統可辨識的路徑。</span><span class="sxs-lookup"><span data-stu-id="106f1-233">If the data that the cmdlet reads or writes has to be a file, the cmdlet should accept Windows PowerShell path input, and the cmdlet should use the [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path) property to translate the Windows PowerShell paths into paths that the file system recognizes.</span></span> <span data-ttu-id="106f1-234">特定的機制包括下列方法：</span><span class="sxs-lookup"><span data-stu-id="106f1-234">The specific mechanisms include the following methods:</span></span>

- [<span data-ttu-id="106f1-235">PSCmdlet. GetResolvedProviderPathFromPSPath。</span><span class="sxs-lookup"><span data-stu-id="106f1-235">System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath)
- [<span data-ttu-id="106f1-236">PSCmdlet. GetUnresolvedProviderPathFromPSPath。</span><span class="sxs-lookup"><span data-stu-id="106f1-236">System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath)
- [<span data-ttu-id="106f1-237">PathIntrinsics. GetResolvedProviderPathFromPSPath。</span><span class="sxs-lookup"><span data-stu-id="106f1-237">System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath)
- [<span data-ttu-id="106f1-238">PathIntrinsics. GetUnresolvedProviderPathFromPSPath。</span><span class="sxs-lookup"><span data-stu-id="106f1-238">System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath)

<span data-ttu-id="106f1-239">如果 Cmdlet 讀取或寫入的資料只是一組字串，而不是檔案，則 Cmdlet 應該使用提供者內容資訊 (`Content` 成員) 來讀取和寫入。</span><span class="sxs-lookup"><span data-stu-id="106f1-239">If the data that the cmdlet reads or writes is only a set of strings instead of a file, the cmdlet should use the provider content information (`Content` member) to read and write.</span></span> <span data-ttu-id="106f1-240">這項資訊是從 [CmdletProvider. InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) 屬性取得。</span><span class="sxs-lookup"><span data-stu-id="106f1-240">This information is obtained from the [System.Management.Automation.Provider.CmdletProvider.InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) property.</span></span> <span data-ttu-id="106f1-241">這些機制可讓其他資料存放區參與資料的讀取和寫入。</span><span class="sxs-lookup"><span data-stu-id="106f1-241">These mechanisms allow other data stores to participate in the reading and writing of data.</span></span>

#### <a name="support-wildcard-characters"></a><span data-ttu-id="106f1-242">支援萬用字元</span><span class="sxs-lookup"><span data-stu-id="106f1-242">Support Wildcard Characters</span></span>

<span data-ttu-id="106f1-243">如果可能的話，Cmdlet 應支援萬用字元。</span><span class="sxs-lookup"><span data-stu-id="106f1-243">A cmdlet should support wildcard characters if possible.</span></span> <span data-ttu-id="106f1-244">Cmdlet 的許多地方都有支援萬用字元 (特別是當參數接受字串來識別一組物件) 的一個物件時。</span><span class="sxs-lookup"><span data-stu-id="106f1-244">Support for wildcard characters occurs in many places in a cmdlet (especially when a parameter takes a string to identify one object from a set of objects).</span></span> <span data-ttu-id="106f1-245">例如， [StopProc 教學](./stopproc-tutorial.md)課程中的範例 **Stop-Proc** Cmdlet 會定義一個 `Name` 參數來處理代表進程名稱的字串。</span><span class="sxs-lookup"><span data-stu-id="106f1-245">For example, the sample **Stop-Proc** cmdlet from the [StopProc Tutorial](./stopproc-tutorial.md) defines a `Name` parameter to handle strings that represent process names.</span></span> <span data-ttu-id="106f1-246">此參數支援萬用字元，讓使用者可以輕鬆地指定要停止的處理常式。</span><span class="sxs-lookup"><span data-stu-id="106f1-246">This parameter supports wildcard characters so that the user can easily specify the processes to stop.</span></span>

<span data-ttu-id="106f1-247">當提供萬用字元的支援時，Cmdlet 作業通常會產生陣列。</span><span class="sxs-lookup"><span data-stu-id="106f1-247">When support for wildcard characters is available, a cmdlet operation usually produces an array.</span></span>
<span data-ttu-id="106f1-248">有時候，支援陣列並不合理，因為使用者一次只能使用一個專案。</span><span class="sxs-lookup"><span data-stu-id="106f1-248">Occasionally, it does not make sense to support an array because the user might use only a single item at a time.</span></span> <span data-ttu-id="106f1-249">例如， [設定位置](/powershell/module/Microsoft.PowerShell.Management/Set-Location) Cmdlet 不需要支援陣列，因為使用者只會設定單一位置。</span><span class="sxs-lookup"><span data-stu-id="106f1-249">For example, the [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet does not need to support an array because the user is setting only a single location.</span></span> <span data-ttu-id="106f1-250">在此情況下，Cmdlet 仍然支援萬用字元，但它會強制解析成單一位置。</span><span class="sxs-lookup"><span data-stu-id="106f1-250">In this instance, the cmdlet still supports wildcard characters, but it forces resolution to a single location.</span></span>

<span data-ttu-id="106f1-251">如需萬用字元字元模式的詳細資訊，請參閱 [在 Cmdlet 參數中支援萬用字元](./supporting-wildcard-characters-in-cmdlet-parameters.md)。</span><span class="sxs-lookup"><span data-stu-id="106f1-251">For more information about wildcard-character patterns, see [Supporting Wildcard Characters in Cmdlet Parameters](./supporting-wildcard-characters-in-cmdlet-parameters.md).</span></span>

#### <a name="defining-objects"></a><span data-ttu-id="106f1-252">定義物件</span><span class="sxs-lookup"><span data-stu-id="106f1-252">Defining Objects</span></span>

<span data-ttu-id="106f1-253">本章節包含定義 Cmdlet 物件和擴充現有物件的指導方針。</span><span class="sxs-lookup"><span data-stu-id="106f1-253">This section contains guidelines for defining objects for cmdlets and for extending existing objects.</span></span>

##### <a name="define-standard-members"></a><span data-ttu-id="106f1-254">定義標準成員</span><span class="sxs-lookup"><span data-stu-id="106f1-254">Define Standard Members</span></span>

<span data-ttu-id="106f1-255">定義標準成員以延伸自訂 Types.ps1xml 檔案中的物件類型 (使用 Windows PowerShell Types.ps1xml 檔案做為範本) 。</span><span class="sxs-lookup"><span data-stu-id="106f1-255">Define standard members to extend an object type in a custom Types.ps1xml file (use the Windows PowerShell Types.ps1xml file as a template).</span></span> <span data-ttu-id="106f1-256">標準成員是由名稱為 PSStandardMembers 的節點所定義。</span><span class="sxs-lookup"><span data-stu-id="106f1-256">Standard members are defined by a node with the name PSStandardMembers.</span></span> <span data-ttu-id="106f1-257">這些定義可讓其他 Cmdlet 和 Windows PowerShell 執行時間以一致的方式處理您的物件。</span><span class="sxs-lookup"><span data-stu-id="106f1-257">These definitions allow other cmdlets and the Windows PowerShell runtime to work with your object in a consistent way.</span></span>

##### <a name="define-objectmembers-to-be-used-as-parameters"></a><span data-ttu-id="106f1-258">定義要當做參數使用的 ObjectMembers</span><span class="sxs-lookup"><span data-stu-id="106f1-258">Define ObjectMembers to Be Used as Parameters</span></span>

<span data-ttu-id="106f1-259">如果您要設計 Cmdlet 的物件，請確定其成員會直接對應至將使用它的 Cmdlet 參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-259">If you are designing an object for a cmdlet, ensure that its members map directly to the parameters of the cmdlets that will use it.</span></span> <span data-ttu-id="106f1-260">此對應可讓物件輕鬆地傳送至管線，並從一個 Cmdlet 傳遞給另一個 Cmdlet。</span><span class="sxs-lookup"><span data-stu-id="106f1-260">This mapping allows the object to be easily sent to the pipeline and to be passed from one cmdlet to another.</span></span>

<span data-ttu-id="106f1-261">由 Cmdlet 所傳回之預先存在的 .NET Framework 物件，通常會遺失腳本開發人員或使用者所需的一些重要或方便的成員。</span><span class="sxs-lookup"><span data-stu-id="106f1-261">Preexisting .NET Framework objects that are returned by cmdlets are frequently missing some important or convenient members that are needed by the script developer or user.</span></span> <span data-ttu-id="106f1-262">這些遺漏的成員對於顯示和建立正確的成員名稱而言特別重要，因為可以將物件正確地傳遞至管線。</span><span class="sxs-lookup"><span data-stu-id="106f1-262">These missing members can be particularly important for display and for creating the correct member names so that the object can be correctly passed to the pipeline.</span></span> <span data-ttu-id="106f1-263">建立自訂的 Types.ps1xml 檔案，以記錄這些必要的成員。</span><span class="sxs-lookup"><span data-stu-id="106f1-263">Create a custom Types.ps1xml file to document these required members.</span></span> <span data-ttu-id="106f1-264">當您建立這個檔案時，我們建議採用下列命名慣例： *<Your_Product_Name>*.Types.ps1xml。</span><span class="sxs-lookup"><span data-stu-id="106f1-264">When you create this file, we recommend the following naming convention: *<Your_Product_Name>*.Types.ps1xml.</span></span>

<span data-ttu-id="106f1-265">例如，您可以將 `Mode` 腳本屬性加入 [FileInfo](/dotnet/api/System.IO.FileInfo) 類型，更清楚地顯示檔案的屬性。</span><span class="sxs-lookup"><span data-stu-id="106f1-265">For example, you could add a `Mode` script property to the [System.IO.FileInfo](/dotnet/api/System.IO.FileInfo) type to display the attributes of a file more clearly.</span></span> <span data-ttu-id="106f1-266">此外，您可以將 `Count` 別名屬性加入至 [system.object](/dotnet/api/System.Array) 類型，以允許一致地使用該屬性名稱 (而不是 `Length`) 。</span><span class="sxs-lookup"><span data-stu-id="106f1-266">Additionally, you could add a `Count` alias property to the [System.Array](/dotnet/api/System.Array) type to allow the consistent use of that property name (instead of `Length`).</span></span>

##### <a name="implement-the-icomparable-interface"></a><span data-ttu-id="106f1-267">執行 IComparable 介面</span><span class="sxs-lookup"><span data-stu-id="106f1-267">Implement the IComparable Interface</span></span>

<span data-ttu-id="106f1-268">在所有輸出物件上，執行 [system.object](/dotnet/api/System.IComparable) 介面。</span><span class="sxs-lookup"><span data-stu-id="106f1-268">Implement a [System.IComparable](/dotnet/api/System.IComparable) interface on all output objects.</span></span>
<span data-ttu-id="106f1-269">這可讓輸出物件輕鬆地輸送至不同的排序和分析 Cmdlet。</span><span class="sxs-lookup"><span data-stu-id="106f1-269">This allows the output objects to be easily piped to various sorting and analysis cmdlets.</span></span>

##### <a name="update-display-information"></a><span data-ttu-id="106f1-270">更新顯示資訊</span><span class="sxs-lookup"><span data-stu-id="106f1-270">Update Display Information</span></span>

<span data-ttu-id="106f1-271">如果物件的顯示未提供預期的結果，請建立該物件的自訂 *\<YourProductName>*.Format.ps1xml 檔。</span><span class="sxs-lookup"><span data-stu-id="106f1-271">If the display for an object does not provide the expected results, create a custom *\<YourProductName>*.Format.ps1xml file for that object.</span></span>

### <a name="support-well-defined-pipeline-input-sc02"></a><span data-ttu-id="106f1-272"> (SC02) 支援定義完善的管線輸入</span><span class="sxs-lookup"><span data-stu-id="106f1-272">Support Well Defined Pipeline Input (SC02)</span></span>

#### <a name="implement-for-the-middle-of-a-pipeline"></a><span data-ttu-id="106f1-273">在管線中間執行</span><span class="sxs-lookup"><span data-stu-id="106f1-273">Implement for the Middle of a Pipeline</span></span>

<span data-ttu-id="106f1-274">執行 Cmdlet，假設它將從管線的中間呼叫 (也就是，其他 Cmdlet 會產生其輸入或使用其輸出) 。</span><span class="sxs-lookup"><span data-stu-id="106f1-274">Implement a cmdlet assuming that it will be called from the middle of a pipeline (that is, other cmdlets will produce its input or consume its output).</span></span> <span data-ttu-id="106f1-275">例如，您可能會假設 `Get-Process` Cmdlet （因為它會產生資料）只會用來做為管線中的第一個 Cmdlet。</span><span class="sxs-lookup"><span data-stu-id="106f1-275">For example, you might assume that the `Get-Process` cmdlet, because it generates data, is used only as the first cmdlet in a pipeline.</span></span>
<span data-ttu-id="106f1-276">不過，因為此 Cmdlet 是針對管線的中間所設計，此 Cmdlet 可讓管線中的先前 Cmdlet 或資料指定要取出的進程。</span><span class="sxs-lookup"><span data-stu-id="106f1-276">However, because this cmdlet is designed for the middle of a pipeline, this cmdlet allows previous cmdlets or data in the pipeline to specify the processes to retrieve.</span></span>

#### <a name="support-input-from-the-pipeline"></a><span data-ttu-id="106f1-277">支援來自管線的輸入</span><span class="sxs-lookup"><span data-stu-id="106f1-277">Support Input from the Pipeline</span></span>

<span data-ttu-id="106f1-278">在 Cmdlet 的每個參數集，至少包含一個支援管線輸入的參數。</span><span class="sxs-lookup"><span data-stu-id="106f1-278">In each parameter set for a cmdlet, include at least one parameter that supports input from the pipeline.</span></span> <span data-ttu-id="106f1-279">管線輸入的支援可讓使用者抓取資料或物件、將資料傳送到正確的參數集，並將結果直接傳遞給 Cmdlet。</span><span class="sxs-lookup"><span data-stu-id="106f1-279">Support for pipeline input allows the user to retrieve data or objects, to send them to the correct parameter set, and to pass the results directly to a cmdlet.</span></span>

<span data-ttu-id="106f1-280">如果 **參數** 屬性包含 `ValueFromPipeline` 關鍵字、 `ValueFromPipelineByPropertyName` 關鍵字屬性或其宣告中的兩個關鍵字，參數就會接受來自管線的輸入。</span><span class="sxs-lookup"><span data-stu-id="106f1-280">A parameter accepts input from the pipeline if the **Parameter** attribute includes the `ValueFromPipeline` keyword, the `ValueFromPipelineByPropertyName` keyword attribute, or both keywords in its declaration.</span></span> <span data-ttu-id="106f1-281">如果參數集中沒有任何參數支援 `ValueFromPipeline` 或 `ValueFromPipelineByPropertyName` 關鍵字，則 Cmdlet 不會有意義地放在另一個 Cmdlet 之後，因為它會忽略任何管線輸入。</span><span class="sxs-lookup"><span data-stu-id="106f1-281">If none of the parameters in a parameter set support the `ValueFromPipeline` or `ValueFromPipelineByPropertyName` keywords, the cmdlet cannot meaningfully be placed after another cmdlet because it will ignore any pipeline input.</span></span>

#### <a name="support-the-processrecord-method"></a><span data-ttu-id="106f1-282">支援 ProcessRecord 方法</span><span class="sxs-lookup"><span data-stu-id="106f1-282">Support the ProcessRecord Method</span></span>

<span data-ttu-id="106f1-283">若要接受管線中上述 Cmdlet 的所有記錄，您的 Cmdlet 必須執行 [ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) 方法。</span><span class="sxs-lookup"><span data-stu-id="106f1-283">To accept all the records from the preceding cmdlet in the pipeline, your cmdlet must implement the [System.Management.Automation.Cmdlet.ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) method.</span></span> <span data-ttu-id="106f1-284">Windows PowerShell 會多次呼叫這個方法，每一筆記錄傳送至您的 Cmdlet。</span><span class="sxs-lookup"><span data-stu-id="106f1-284">Windows PowerShell calls this method multiple times, once for every record that is sent to your cmdlet.</span></span>

### <a name="write-single-records-to-the-pipeline-sc03"></a><span data-ttu-id="106f1-285">將單一記錄寫入管線 (SC03) </span><span class="sxs-lookup"><span data-stu-id="106f1-285">Write Single Records to the Pipeline (SC03)</span></span>

<span data-ttu-id="106f1-286">當 Cmdlet 傳回物件時，此 Cmdlet 應該在產生物件時立即將其寫入。</span><span class="sxs-lookup"><span data-stu-id="106f1-286">When a cmdlet returns objects, the cmdlet should write the objects immediately as they are generated.</span></span> <span data-ttu-id="106f1-287">Cmdlet 不應該保留它們，以便將它們緩衝至組合的陣列中。</span><span class="sxs-lookup"><span data-stu-id="106f1-287">The cmdlet should not hold them in order to buffer them into a combined array.</span></span> <span data-ttu-id="106f1-288">以輸入的形式接收物件的 Cmdlet 將能夠處理、顯示或處理並顯示輸出物件，而不會有延遲。</span><span class="sxs-lookup"><span data-stu-id="106f1-288">The cmdlets that receive the objects as input will then be able to process, display, or process and display the output objects without delay.</span></span> <span data-ttu-id="106f1-289">一次產生一個輸出物件的指令程式，應該呼叫 [WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) 方法。</span><span class="sxs-lookup"><span data-stu-id="106f1-289">A cmdlet that generates output objects one at a time should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="106f1-290">以批次方式產生輸出物件的 Cmdlet (例如，因為基礎 API 會傳回輸出物件的陣列) 應該呼叫 [WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) 方法，並將其第二個參數設定為 `true` 。</span><span class="sxs-lookup"><span data-stu-id="106f1-290">A cmdlet that generates output objects in batches (for example, because an underlying API returns an array of output objects) should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) Method with its second parameter set to `true`.</span></span>

### <a name="make-cmdlets-case-insensitive-and-case-preserving-sc04"></a><span data-ttu-id="106f1-291">將 Cmdlet Case-Insensitive，並 Case-Preserving (SC04) </span><span class="sxs-lookup"><span data-stu-id="106f1-291">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>

<span data-ttu-id="106f1-292">根據預設，Windows PowerShell 本身不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="106f1-292">By default, Windows PowerShell itself is case-insensitive.</span></span> <span data-ttu-id="106f1-293">不過，因為它會處理許多預先存在的系統，Windows PowerShell 確實會保留大小寫，以方便操作和相容性。</span><span class="sxs-lookup"><span data-stu-id="106f1-293">However, because it deals with many preexisting systems, Windows PowerShell does preserve case for ease of operation and compatibility.</span></span>
<span data-ttu-id="106f1-294">換句話說，如果字元是以大寫字母提供，Windows PowerShell 會將其保留為大寫字母。</span><span class="sxs-lookup"><span data-stu-id="106f1-294">In other words, if a character is supplied in uppercase letters, Windows PowerShell keeps it in uppercase letters.</span></span> <span data-ttu-id="106f1-295">針對可正常運作的系統，Cmdlet 必須遵循此慣例。</span><span class="sxs-lookup"><span data-stu-id="106f1-295">For systems to work well, a cmdlet needs to follow this convention.</span></span> <span data-ttu-id="106f1-296">可能的話，應該以不區分大小寫的方式操作。</span><span class="sxs-lookup"><span data-stu-id="106f1-296">If possible, it should operate in a case-insensitive way.</span></span> <span data-ttu-id="106f1-297">不過，它應該會針對稍後在命令或管線中發生的 Cmdlet 保留原始案例。</span><span class="sxs-lookup"><span data-stu-id="106f1-297">It should, however, preserve the original case for cmdlets that occur later in a command or in the pipeline.</span></span>

## <a name="see-also"></a><span data-ttu-id="106f1-298">另請參閱</span><span class="sxs-lookup"><span data-stu-id="106f1-298">See Also</span></span>

[<span data-ttu-id="106f1-299">必要的開發指導方針</span><span class="sxs-lookup"><span data-stu-id="106f1-299">Required Development Guidelines</span></span>](./required-development-guidelines.md)

[<span data-ttu-id="106f1-300">建議性開發指導方針</span><span class="sxs-lookup"><span data-stu-id="106f1-300">Advisory Development Guidelines</span></span>](./advisory-development-guidelines.md)

[<span data-ttu-id="106f1-301">撰寫 Windows PowerShell Cmdlet</span><span class="sxs-lookup"><span data-stu-id="106f1-301">Writing a Windows PowerShell Cmdlet</span></span>](./writing-a-windows-powershell-cmdlet.md)
