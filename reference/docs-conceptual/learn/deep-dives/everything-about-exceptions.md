---
title: 您想知道有關於例外狀況的一切 (英文)
description: 在撰寫程式碼時，錯誤處理只是生命必經的歷程。
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: cd17ae6b5ded052c93923b648155a4dda8956b34
ms.sourcegitcommit: ba7315a496986451cfc1296b659d73ea2373d3f0
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/10/2020
ms.locfileid: "90012556"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="df1d5-103">您想知道有關於例外狀況的一切 (英文)</span><span class="sxs-lookup"><span data-stu-id="df1d5-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="df1d5-104">在撰寫程式碼時，錯誤處理只是生命必經的歷程。</span><span class="sxs-lookup"><span data-stu-id="df1d5-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="df1d5-105">我們通常可以檢查並驗證預期行為的條件。</span><span class="sxs-lookup"><span data-stu-id="df1d5-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="df1d5-106">當發生未預期的情況時，我們會轉換成例外狀況處理。</span><span class="sxs-lookup"><span data-stu-id="df1d5-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="df1d5-107">您可以輕鬆地處理其他人的程式碼所產生的例外狀況，或者您可以產生自己的例外狀況供其他人處理。</span><span class="sxs-lookup"><span data-stu-id="df1d5-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="df1d5-108">本文的[原始版本][]出自 [@KevinMarquette][] 所撰寫的部落格。</span><span class="sxs-lookup"><span data-stu-id="df1d5-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="df1d5-109">PowerShell 小組感謝 Kevin 分享此內容。</span><span class="sxs-lookup"><span data-stu-id="df1d5-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="df1d5-110">請前往 [PowerShellExplained.com][] 瀏覽他的部落格。</span><span class="sxs-lookup"><span data-stu-id="df1d5-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="df1d5-111">基本術語</span><span class="sxs-lookup"><span data-stu-id="df1d5-111">Basic terminology</span></span>

<span data-ttu-id="df1d5-112">我們必須先討論一些基本的詞彙，然後再跳到這一段。</span><span class="sxs-lookup"><span data-stu-id="df1d5-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="df1d5-113">例外狀況</span><span class="sxs-lookup"><span data-stu-id="df1d5-113">Exception</span></span>

<span data-ttu-id="df1d5-114">例外狀況就像是一般錯誤處理無法處理問題時所建立的事件。</span><span class="sxs-lookup"><span data-stu-id="df1d5-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="df1d5-115">嘗試將以零除某數字或記憶體不足，就是建立例外狀況的一些範例。</span><span class="sxs-lookup"><span data-stu-id="df1d5-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="df1d5-116">有時候，您所使用的程式碼作者會在發生特定問題時，建立例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="df1d5-117">Throw 與 Catch</span><span class="sxs-lookup"><span data-stu-id="df1d5-117">Throw and Catch</span></span>

<span data-ttu-id="df1d5-118">發生例外狀況時，我們會說系統擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="df1d5-119">若要處理擲回的例外狀況，您必須加以捕捉。</span><span class="sxs-lookup"><span data-stu-id="df1d5-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="df1d5-120">如果擲回例外狀況，但您未捕捉到任何狀況，指令碼就會停止執行。</span><span class="sxs-lookup"><span data-stu-id="df1d5-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="df1d5-121">呼叫堆疊</span><span class="sxs-lookup"><span data-stu-id="df1d5-121">The call stack</span></span>

<span data-ttu-id="df1d5-122">呼叫堆疊是已呼叫彼此的函式清單。</span><span class="sxs-lookup"><span data-stu-id="df1d5-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="df1d5-123">呼叫函式時，函式會加入至堆疊或清單頂端。</span><span class="sxs-lookup"><span data-stu-id="df1d5-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="df1d5-124">當函式結束或傳回時，就會從堆疊中移除。</span><span class="sxs-lookup"><span data-stu-id="df1d5-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="df1d5-125">當系統擲回例外狀況時，會檢查該呼叫堆疊，以便讓例外狀況處理常式加以捕捉。</span><span class="sxs-lookup"><span data-stu-id="df1d5-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="df1d5-126">終止和非終止錯誤</span><span class="sxs-lookup"><span data-stu-id="df1d5-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="df1d5-127">例外狀況通常是終止錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="df1d5-128">系統會捕捉擲回的例外狀況，或終止目前的執行。</span><span class="sxs-lookup"><span data-stu-id="df1d5-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="df1d5-129">根據預設，非終止錯誤是由 `Write-Error` 所產生，並且會將錯誤新增至輸出資料流程而不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="df1d5-130">我指出這個問題的原因是，`Write-Error` 和其他非終止錯誤都不會觸發 `catch`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="df1d5-131">忍受例外狀況</span><span class="sxs-lookup"><span data-stu-id="df1d5-131">Swallowing an exception</span></span>

<span data-ttu-id="df1d5-132">當您捕捉到錯誤時，就會隱藏錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="df1d5-133">請謹慎執行此動作，因為它可能會讓疑難排解問題變得非常艱難。</span><span class="sxs-lookup"><span data-stu-id="df1d5-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="df1d5-134">舊版命令語法</span><span class="sxs-lookup"><span data-stu-id="df1d5-134">Basic command syntax</span></span>

<span data-ttu-id="df1d5-135">以下是 PowerShell 中用以處理基本例外狀況之語法的快速概觀。</span><span class="sxs-lookup"><span data-stu-id="df1d5-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="df1d5-136">Throw</span><span class="sxs-lookup"><span data-stu-id="df1d5-136">Throw</span></span>

<span data-ttu-id="df1d5-137">若要建立自己的例外狀況事件，我們會擲回具有 `throw` 關鍵字的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="df1d5-138">這會建立終止錯誤的執行階段例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="df1d5-139">它是由呼叫函式中的 `catch` 來處理，或是結束具有如下訊息的指令碼。</span><span class="sxs-lookup"><span data-stu-id="df1d5-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="df1d5-140">Write-Error -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="df1d5-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="df1d5-141">我說過，根據預設，`Write-Error` 不會擲回終止錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="df1d5-142">如果您指定 `-ErrorAction Stop`，`Write-Error` 會產生可使用 `catch` 處理的終止錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-142">If you specify `-ErrorAction Stop`, `Write-Error`generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="df1d5-143">感謝 Lee Dailey 以這種方式使用 `-ErrorAction Stop` 來發出提醒。</span><span class="sxs-lookup"><span data-stu-id="df1d5-143">Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="df1d5-144">Cmdlet -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="df1d5-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="df1d5-145">如果您在任何進階函式或 Cmdlet 上指定 `-ErrorAction Stop`，結果會將所有 `Write-Error` 陳述式轉換為停止執行或可由 `catch`處理的終止錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="df1d5-146">Try/Catch</span><span class="sxs-lookup"><span data-stu-id="df1d5-146">Try/Catch</span></span>

<span data-ttu-id="df1d5-147">例外狀況處理在 PowerShell 中的運作方式 (以及許多其他程式設計語言) 是您先 `try` 一段程式碼，如果它擲回錯誤，您就可以 `catch` 該程式碼。</span><span class="sxs-lookup"><span data-stu-id="df1d5-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="df1d5-148">以下是一個簡短的範例。</span><span class="sxs-lookup"><span data-stu-id="df1d5-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="df1d5-149">只有在發生終止錯誤時，才會執行 `catch` 指令碼。</span><span class="sxs-lookup"><span data-stu-id="df1d5-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="df1d5-150">如果 `try` 正確執行，則會略過 `catch`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="df1d5-151">Try/Finally</span><span class="sxs-lookup"><span data-stu-id="df1d5-151">Try/Finally</span></span>

<span data-ttu-id="df1d5-152">有時候，您不需要處理錯誤，但如果發生例外狀況，仍然需要一些程式碼才能執行。</span><span class="sxs-lookup"><span data-stu-id="df1d5-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="df1d5-153">`finally` 指令碼正是如此。</span><span class="sxs-lookup"><span data-stu-id="df1d5-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="df1d5-154">請看一下這個範例：</span><span class="sxs-lookup"><span data-stu-id="df1d5-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="df1d5-155">每當您開啟或連線至資源時，您應該將指令碼關閉。</span><span class="sxs-lookup"><span data-stu-id="df1d5-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="df1d5-156">如果 `ExecuteNonQuery()` 擲回例外狀況，則不會關閉連線。</span><span class="sxs-lookup"><span data-stu-id="df1d5-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="df1d5-157">以下是 `try/finally` 區塊內的相同程式碼。</span><span class="sxs-lookup"><span data-stu-id="df1d5-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="df1d5-158">在此範例中，如果發生錯誤，連線就會關閉。</span><span class="sxs-lookup"><span data-stu-id="df1d5-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="df1d5-159">即使沒有發生錯誤，連線也會關閉。</span><span class="sxs-lookup"><span data-stu-id="df1d5-159">It also is closed if there's no error.</span></span> <span data-ttu-id="df1d5-160">`finally` 指令碼每次都會執行。</span><span class="sxs-lookup"><span data-stu-id="df1d5-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="df1d5-161">由於您並未捕捉例外狀況，因此例外狀況仍然會傳播至呼叫堆疊。</span><span class="sxs-lookup"><span data-stu-id="df1d5-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="df1d5-162">Try/Catch/Finally</span><span class="sxs-lookup"><span data-stu-id="df1d5-162">Try/Catch/Finally</span></span>

<span data-ttu-id="df1d5-163">`catch` 與 `finally` 搭配使用，完全有效。</span><span class="sxs-lookup"><span data-stu-id="df1d5-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="df1d5-164">在大部分的情況下，您會使用其中一種，但您也可能會發現同時使用這兩者的情況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="df1d5-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="df1d5-165">$PSItem</span></span>

<span data-ttu-id="df1d5-166">既然已經瞭解基本概念，我們就可以更加深入地進行探討。</span><span class="sxs-lookup"><span data-stu-id="df1d5-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="df1d5-167">在 `catch` 區塊內，會有類型 `ErrorRecord` 的自動變數 (`$PSItem` 或 `$_`)，其中包含例外狀況的相關詳細資料。</span><span class="sxs-lookup"><span data-stu-id="df1d5-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="df1d5-168">以下是一些重要屬性的快速概觀。</span><span class="sxs-lookup"><span data-stu-id="df1d5-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="df1d5-169">在這些範例中，我在 `ReadAllText` 中使用了無效的路徑來產生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="df1d5-170">PSItem.ToString()</span><span class="sxs-lookup"><span data-stu-id="df1d5-170">PSItem.ToString()</span></span>

<span data-ttu-id="df1d5-171">這會提供您要在記錄和一般輸出中使用的最單純的訊息。</span><span class="sxs-lookup"><span data-stu-id="df1d5-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="df1d5-172">如果 `$PSItem` 放在字串內，則會自動呼叫 `ToString()`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="df1d5-173">$PSItem.InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="df1d5-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="df1d5-174">此屬性包含 PowerShell 針對擲回例外狀況的函式或指令碼所收集的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="df1d5-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="df1d5-175">以下是我所建立之範例例外狀況的 `InvocationInfo`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="df1d5-176">此處的重要詳細資料會顯示 `ScriptName`、程式碼的 `Line`，以及叫用開始的 `ScriptLineNumber`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="df1d5-177">$PSItem.ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="df1d5-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="df1d5-178">這個屬性會顯示在產生例外狀況的程式碼中，函式呼叫的順序。</span><span class="sxs-lookup"><span data-stu-id="df1d5-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="df1d5-179">我只會呼叫相同指令碼中的函式，但如果牽涉到多個指令碼，這會追蹤呼叫。</span><span class="sxs-lookup"><span data-stu-id="df1d5-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="df1d5-180">$PSItem.Exception</span><span class="sxs-lookup"><span data-stu-id="df1d5-180">$PSItem.Exception</span></span>

<span data-ttu-id="df1d5-181">這是所擲回的實際例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="df1d5-182">$PSItem.Exception.Message</span><span class="sxs-lookup"><span data-stu-id="df1d5-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="df1d5-183">這是描述例外狀況的一般訊息，而且在進行疑難排解時，是很好的起點。</span><span class="sxs-lookup"><span data-stu-id="df1d5-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="df1d5-184">大部分的例外狀況都有預設訊息，但是在擲回例外狀況時，也可以設定為自訂內容。</span><span class="sxs-lookup"><span data-stu-id="df1d5-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="df1d5-185">這也是呼叫 `$PSItem.ToString()` 時傳回的訊息 (如果沒有在 `ErrorRecord` 進行設定的話)。</span><span class="sxs-lookup"><span data-stu-id="df1d5-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="df1d5-186">$PSItem.Exception.InnerException</span><span class="sxs-lookup"><span data-stu-id="df1d5-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="df1d5-187">例外狀況可以包含內部例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="df1d5-188">當您呼叫的程式碼會捕捉到例外狀況，並擲回不同的例外狀況時，通常會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="df1d5-189">原始例外狀況會放置在新的例外狀況中。</span><span class="sxs-lookup"><span data-stu-id="df1d5-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="df1d5-190">稍後當我談到重新擲回例外狀況時，我將會重新回顧這種情況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="df1d5-191">$PSItem.Exception.StackTrace</span><span class="sxs-lookup"><span data-stu-id="df1d5-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="df1d5-192">這是例外狀況的 `StackTrace`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="df1d5-193">我示範了上述的 `ScriptStackTrace`，不過它的作用在於呼叫受控程式碼。</span><span class="sxs-lookup"><span data-stu-id="df1d5-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="df1d5-194">當受控程式碼擲回事件時，您只會取得此堆疊追蹤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="df1d5-195">我直接呼叫 .NET framework 函式，這就是我們在此範例中可以看到的所有內容。</span><span class="sxs-lookup"><span data-stu-id="df1d5-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="df1d5-196">一般而言，當您在查看堆疊追蹤時，您就是在尋找程式碼的停止位置，以及系統呼叫開始的位置。</span><span class="sxs-lookup"><span data-stu-id="df1d5-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="df1d5-197">可以運作，但出現例外狀況</span><span class="sxs-lookup"><span data-stu-id="df1d5-197">Working with exceptions</span></span>

<span data-ttu-id="df1d5-198">除了基本語法和例外狀況屬性以外，還有更多例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="df1d5-199">捕捉類型例外狀況</span><span class="sxs-lookup"><span data-stu-id="df1d5-199">Catching typed exceptions</span></span>

<span data-ttu-id="df1d5-200">您可以選擇性地使用所捕捉的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="df1d5-201">例外狀況各具類型，而您可以指定自己想要捕捉的例外狀況類型。</span><span class="sxs-lookup"><span data-stu-id="df1d5-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="df1d5-202">系統會檢查每個 `catch` 區塊的例外狀況類型，直到找到符合您例外狀況的類型為止。</span><span class="sxs-lookup"><span data-stu-id="df1d5-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="df1d5-203">請務必瞭解，例外狀況可以由其他例外狀況繼承獲得。</span><span class="sxs-lookup"><span data-stu-id="df1d5-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="df1d5-204">在上述範例中，`FileNotFoundException` 便是由 `IOException` 繼承所獲得的。</span><span class="sxs-lookup"><span data-stu-id="df1d5-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="df1d5-205">因此，如果 `IOException` 是第一個，則系統會改為呼叫它。</span><span class="sxs-lookup"><span data-stu-id="df1d5-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="df1d5-206">即使有多個相符例外狀況，也只會叫用一個捕捉區塊。</span><span class="sxs-lookup"><span data-stu-id="df1d5-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="df1d5-207">如果有 `System.IO.PathTooLongException`，`IOException` 會相符，但如果有 `InsufficientMemoryException`，則不會有任何項目捕捉它，而且會向上傳播堆疊。</span><span class="sxs-lookup"><span data-stu-id="df1d5-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="df1d5-208">一次捕捉多個類型</span><span class="sxs-lookup"><span data-stu-id="df1d5-208">Catch multiple types at once</span></span>

<span data-ttu-id="df1d5-209">您可以使用相同的 `catch` 陳述式來捕捉多個例外狀況類型。</span><span class="sxs-lookup"><span data-stu-id="df1d5-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="df1d5-210">感謝您 `/u/Sheppard_Ra` 提出這項新增建議。</span><span class="sxs-lookup"><span data-stu-id="df1d5-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="df1d5-211">擲回類型例外狀況</span><span class="sxs-lookup"><span data-stu-id="df1d5-211">Throwing typed exceptions</span></span>

<span data-ttu-id="df1d5-212">您可以在 PowerShell 中擲回類型例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="df1d5-213">而不是使用字串來呼叫 `throw`：</span><span class="sxs-lookup"><span data-stu-id="df1d5-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="df1d5-214">使用例外狀況加速器，如下所示：</span><span class="sxs-lookup"><span data-stu-id="df1d5-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="df1d5-215">但是當您這樣做時，就必須指定訊息。</span><span class="sxs-lookup"><span data-stu-id="df1d5-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="df1d5-216">您也可以建立要擲回之例外狀況的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="df1d5-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="df1d5-217">當您這麼做時，訊息是選擇性的，因為系統具有所有內建例外狀況的預設訊息。</span><span class="sxs-lookup"><span data-stu-id="df1d5-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="df1d5-218">如果您不是使用 PowerShell 5.0 或更新版本，則必須使用舊版的 `New-Object` 方法。</span><span class="sxs-lookup"><span data-stu-id="df1d5-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="df1d5-219">藉由使用類型例外狀況，您 (或其他人) 可以依照上一節所述的類型來捕捉例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="df1d5-220">Write-Error -Exception</span><span class="sxs-lookup"><span data-stu-id="df1d5-220">Write-Error -Exception</span></span>

<span data-ttu-id="df1d5-221">我們可以將這些類型例外狀況新增至 `Write-Error`，而且仍然可以按照例外狀況類型 `catch` 錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="df1d5-222">按照列範例所示的方式使用 `Write-Error`：</span><span class="sxs-lookup"><span data-stu-id="df1d5-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="df1d5-223">然後，我們可加以捕捉，如下所示：</span><span class="sxs-lookup"><span data-stu-id="df1d5-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="df1d5-224">.NET 例外狀況的大型清單</span><span class="sxs-lookup"><span data-stu-id="df1d5-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="df1d5-225">我已藉由 [Reddit/r/PowerShell community][]的協助來編譯主要清單，其中包含數以百計的 .NET 例外狀況，藉此充實這篇文章的內容。</span><span class="sxs-lookup"><span data-stu-id="df1d5-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="df1d5-226">[.NET 例外狀況的大型清單][]</span><span class="sxs-lookup"><span data-stu-id="df1d5-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="df1d5-227">我一開始先搜尋該清單，找出充分適用於我的情況的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="df1d5-228">您應該嘗試使用基礎 `System` 命名空間中的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="df1d5-229">例外狀況皆為物件</span><span class="sxs-lookup"><span data-stu-id="df1d5-229">Exceptions are objects</span></span>

<span data-ttu-id="df1d5-230">如果您開始使用許多類型例外狀況，請記住它們都是物件。</span><span class="sxs-lookup"><span data-stu-id="df1d5-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="df1d5-231">不同的例外狀況有不同的建構函式和屬性。</span><span class="sxs-lookup"><span data-stu-id="df1d5-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="df1d5-232">如果我們查看 `System.IO.FileNotFoundException` 的 [FileNotFoundException][] 檔，我們會看到我們可以傳入的訊息和檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="df1d5-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="df1d5-233">而且它具有公開該檔案路徑的 `FileName` 屬性。</span><span class="sxs-lookup"><span data-stu-id="df1d5-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="df1d5-234">如需其他建構函式和物件屬性，請參閱 [.NET 文件][]。</span><span class="sxs-lookup"><span data-stu-id="df1d5-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="df1d5-235">重新擲回例外狀況</span><span class="sxs-lookup"><span data-stu-id="df1d5-235">Re-throwing an exception</span></span>

<span data-ttu-id="df1d5-236">如果您要在 `catch` 區塊中 `throw` 相同的例外狀況，請不要加以 `catch`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="df1d5-237">您應該僅 `catch` 您打算處理的例外狀況，或在例外狀況發生時執行某些動作。</span><span class="sxs-lookup"><span data-stu-id="df1d5-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="df1d5-238">有時候您會想要對例外狀況執行動作，但是系統會重新擲回例外狀況，讓下游可加以處理。</span><span class="sxs-lookup"><span data-stu-id="df1d5-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="df1d5-239">我們可以探索訊息或記錄的所在地附近寫入訊息或記錄問題，卻將問題交給更高層的堆疊處理。</span><span class="sxs-lookup"><span data-stu-id="df1d5-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="df1d5-240">有趣的是，我們可以從 `catch` 內呼叫 `throw`，然後重新擲回目前的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="df1d5-241">我們想要重新擲回例外狀況，以保留原始的執行資訊 (例如來來源指令碼與行號)。</span><span class="sxs-lookup"><span data-stu-id="df1d5-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="df1d5-242">如果在此時擲回新的例外狀況，它會隱藏例外狀況開始的位置。</span><span class="sxs-lookup"><span data-stu-id="df1d5-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="df1d5-243">重新擲回例外狀況</span><span class="sxs-lookup"><span data-stu-id="df1d5-243">Re-throwing a new exception</span></span>

<span data-ttu-id="df1d5-244">若您捕捉某個例外狀況，卻想要擲回不同的例外狀況，則應該將原始例外狀況嵌套在新的例外狀況中。</span><span class="sxs-lookup"><span data-stu-id="df1d5-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="df1d5-245">這可讓其他人在堆疊下進行存取，做為 `$PSItem.Exception.InnerException`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="df1d5-246">$PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="df1d5-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="df1d5-247">我不喜歡使用 `throw` 來處理原始例外狀況的問題，就是錯誤訊息會指向 `throw` 的陳述式，並指出該行是問題所在。</span><span class="sxs-lookup"><span data-stu-id="df1d5-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="df1d5-248">出現錯誤訊息指出我的指令碼已中斷，是因為我在第 31 行呼叫 `throw` 是您的指令碼使用者無法看見的錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="df1d5-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="df1d5-249">該錯誤訊息無法提供任何實用資訊。</span><span class="sxs-lookup"><span data-stu-id="df1d5-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="df1d5-250">Dexter Dhami 指出，我可以使用 `ThrowTerminatingError()` 來加以更正。</span><span class="sxs-lookup"><span data-stu-id="df1d5-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="df1d5-251">假設在稱為 `Get-Resource` 的函式內呼叫了 `ThrowTerminatingError()`，這就是我們會看到的錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="df1d5-252">您是否看到它如何指出 `Get-Resource` 函式為問題的來源？</span><span class="sxs-lookup"><span data-stu-id="df1d5-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="df1d5-253">這會提供使用者實用的資訊。</span><span class="sxs-lookup"><span data-stu-id="df1d5-253">That tells the user something useful.</span></span>

<span data-ttu-id="df1d5-254">因為 `$PSItem` 是 `ErrorRecord`，所以我們也可以使用 `ThrowTerminatingError` 以這種方式重新擲回。</span><span class="sxs-lookup"><span data-stu-id="df1d5-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="df1d5-255">這會將錯誤的來源變更為 Cmdlet，並將您的函式的內部內容對 Cmdlet 的使用者隱藏。</span><span class="sxs-lookup"><span data-stu-id="df1d5-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="df1d5-256">Try 可以建立終止錯誤</span><span class="sxs-lookup"><span data-stu-id="df1d5-256">Try can create terminating errors</span></span>

<span data-ttu-id="df1d5-257">Kirk Munro 指出，在 `try/catch` 區塊中，某些例外狀況僅僅是終止錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="df1d5-258">以下是他提供給我的範例，該範例會產生除以零的執行階段例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="df1d5-259">然後叫用例外狀況，如下所示，便會產生錯誤並仍然輸出訊息。</span><span class="sxs-lookup"><span data-stu-id="df1d5-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="df1d5-260">但藉由將相同的程式碼放在 `try/catch` 中，我們會看到出現其他狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="df1d5-261">我們會看到錯誤變成終止錯誤，而且不會輸出第一個訊息。</span><span class="sxs-lookup"><span data-stu-id="df1d5-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="df1d5-262">我不喜歡這種方式，就是您可以在函式中使用此程式碼，若是有人使用 `try/catch`，則其運作方式便會有所不同。</span><span class="sxs-lookup"><span data-stu-id="df1d5-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="df1d5-263">我還未遇到這個問題，但它是一種需要留意的極端狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="df1d5-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span><span class="sxs-lookup"><span data-stu-id="df1d5-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="df1d5-265">`$PSCmdlet.ThrowTerminatingError()` 的其中一項差異是，它會在您的 Cmdlet 內建立終止錯誤，但是在離開 Cmdlet 之後，它會轉換為非終止錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="df1d5-266">這會將負擔留給函式的呼叫者，以決定如何處理錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="df1d5-267">他們可以使用 `-ErrorAction Stop` 或從 `try{...}catch{...}`內呼叫它，將其轉換回終止錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="df1d5-268">公用函式範本</span><span class="sxs-lookup"><span data-stu-id="df1d5-268">Public function templates</span></span>

<span data-ttu-id="df1d5-269">我對 Kirk Munro 的對話的最後一項要點就是，他在所有的進階函式中都在每個 `begin`、`process` 和 `end` 區塊附近放置 `try{...}catch{...}`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="df1d5-270">在這些一般 catch 區塊中，他會使用一行 `$PSCmdlet.ThrowTerminatingError($PSItem)` 來處理所有離開函式的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="df1d5-271">由於所有內容都是位於其函式內的 `try` 陳述式中，因此所有動作都會以一致的方式運作。</span><span class="sxs-lookup"><span data-stu-id="df1d5-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="df1d5-272">這也會為終端使用者提供清除錯誤，並對產生的錯誤隱藏內部程式碼。</span><span class="sxs-lookup"><span data-stu-id="df1d5-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="df1d5-273">陷阱</span><span class="sxs-lookup"><span data-stu-id="df1d5-273">Trap</span></span>

<span data-ttu-id="df1d5-274">我將重點放在例外狀況的 `try/catch` 層面。</span><span class="sxs-lookup"><span data-stu-id="df1d5-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="df1d5-275">但是在總結之前，我必須先提一下一個舊版功能。</span><span class="sxs-lookup"><span data-stu-id="df1d5-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="df1d5-276">`trap` 會放在指令碼或函式中，以捕捉出現在該範圍內的所有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="df1d5-277">發生例外狀況時，會執行 `trap` 中的程式碼，然後再繼續執行正常的程式碼。</span><span class="sxs-lookup"><span data-stu-id="df1d5-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="df1d5-278">如果發生多個例外狀況，則會一再呼叫陷阱。</span><span class="sxs-lookup"><span data-stu-id="df1d5-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="df1d5-279">我個人從未採用過這種方法，但是我可以在系統管理員或控制器指令碼中看到記錄任何和所有例外狀況的值，然後仍繼續執行。</span><span class="sxs-lookup"><span data-stu-id="df1d5-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="df1d5-280">關閉備註</span><span class="sxs-lookup"><span data-stu-id="df1d5-280">Closing remarks</span></span>

<span data-ttu-id="df1d5-281">將適當的例外狀況處理新增至您的指令碼不僅會使其更穩定，還可讓您針對這些例外狀況進行疑難排解時更輕鬆。</span><span class="sxs-lookup"><span data-stu-id="df1d5-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="df1d5-282">我花了很多時間來談論 `throw`，因為這是在討論例外狀況處理時的核心概念。</span><span class="sxs-lookup"><span data-stu-id="df1d5-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="df1d5-283">PowerShell 也提供我們 `Write-Error`，可因應您使用 `throw` 時的所有情況。</span><span class="sxs-lookup"><span data-stu-id="df1d5-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="df1d5-284">因此，請不要認為在閱讀此之後，您必須使用 `throw`。</span><span class="sxs-lookup"><span data-stu-id="df1d5-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="df1d5-285">既然我已經花時間撰寫有關例外狀況處理的詳細資訊，現在我要將重點切換到使用 `Write-Error -Stop` 在我的程式碼中產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="df1d5-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="df1d5-286">我也會採納 Kirk 的建議，並針對每個函數使 `ThrowTerminatingError` 成為我的 goto 例外處理常式。</span><span class="sxs-lookup"><span data-stu-id="df1d5-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[原始版本]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[.NET 例外狀況的大型清單]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: /dotnet/api/System.IO.FileNotFoundException
[.NET 文件]: /dotnet/api
[.NET documentation]: /dotnet/api
